---
import "../../../styles/global.css";
import fs from "node:fs/promises";
import path from "node:path";

function niceName(slug: string) {
  return slug
    .replace(/[-_]+/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .replace(/\b\w/g, (c) => c.toUpperCase());
}

// ---------- OPTIONAL per-card overrides ----------
// Create: public/cards/<sport>/<set>/meta.json
type MetaMap = Record<
  string,
  Partial<{
    player: string;
    team: string;
    rc: boolean;
    auto: boolean;
    patch: boolean;
    relic: boolean;
    numbered: string; // e.g. "01/50"
    parallel: string; // e.g. "Tin Type", "Purple Foil"
  }>
>;

function isImageFile(f: string) {
  return /\.(webp|png|jpe?g|gif)$/i.test(f);
}

async function dirExists(p: string) {
  try {
    const st = await fs.stat(p);
    return st.isDirectory();
  } catch {
    return false;
  }
}

function toUrl(folder: string, set: string, sub: string | null, file: string) {
  const mid = sub ? `/${sub}` : "";
  return `/cards/${folder}/${set}${mid}/${file}`;
}

// Normalizes front/back/thumb matching
function cardKey(file: string) {
  return file
    .replace(/\.[^.]+$/, "") // drop extension
    .replace(/__front$/i, "")
    .replace(/__back$/i, "");
}

function formatNumbered(n: string | number, total: string | number) {
  const nn = String(n);
  const tt = String(total);
  const w = Math.max(tt.length, 2); // at least 2 digits (01/50, 02/05, etc.)
  const pad = (s: string) => s.padStart(w, "0");
  return `${pad(nn)}/${pad(tt)}`;
}

function parseNumberedToken(token: string): string | null {
  const t = token.toLowerCase();

  // numbered-02of05, 02of05, 2of50, etc.
  const m1 = t.match(/(\d+)\s*of\s*(\d+)/i);
  if (m1) return formatNumbered(m1[1], m1[2]);

  // 2/50, 02/50
  const m2 = t.match(/(\d+)\s*\/\s*(\d+)/);
  if (m2) return formatNumbered(m2[1], m2[2]);

  return null;
}

/**
 * Better inference for your new naming scheme:
 * player__team__rc__numbered-01of50__parallel-tin-type__...__front.webp
 *
 * If filename doesn't contain "__", it falls back to the older heuristic.
 */
function inferFromFilename(filename: string) {
  const base = filename.replace(/\.[^.]+$/, "");
  const lower = base.toLowerCase();

  // default fields
  let player = "";
  let team = "";

  let rc = false;
  let auto = false;
  let patch = false;
  let relic = false;
  let numbered: string | null = null;
  let parallel = false;
  let parallelText = "";

  // Preferred: structured "__" parsing
  if (base.includes("__")) {
    const segs = base.split("__").filter(Boolean);

    // player/team are first two segments if present
    if (segs[0]) player = niceName(segs[0]);
    if (segs[1]) team = niceName(segs[1]);

    // Remaining segments become tags/attrs; ignore trailing "front"/"back"
    const rest = segs.slice(2).map((s) => s.trim()).filter(Boolean);

    for (const raw of rest) {
      const t = raw.toLowerCase();

      if (t === "front" || t === "back") continue;

      if (t === "rc" || t === "rookie") rc = true;

      if (t === "auto" || t === "autograph" || t === "signature" || t === "sig") auto = true;

      if (t === "patch" || t === "jersey") patch = true;

      if (t === "relic" || t === "relic-card") relic = true;

      // numbered token variants
      if (t.startsWith("numbered-")) {
        const n = parseNumberedToken(t.replace(/^numbered-/, ""));
        if (n) numbered = n;
      } else {
        const n = parseNumberedToken(t);
        if (n) numbered = n;
      }

      // parallel token variants
      if (t.startsWith("parallel-")) {
        parallel = true;
        const val = raw.slice("parallel-".length);
        parallelText = niceName(val);
      }

      // "tin-type" may appear as its own token
      if (t === "tin-type" || t === "tintype") {
        parallel = true;
        if (!parallelText) parallelText = "Tin Type";
      }

      // Some sets use foil/holo/etc without explicit "parallel-"
      if (/(foil|holo|refractor|prizm|mosaic|scope|wave)/i.test(t)) {
        parallel = true;
        if (!parallelText && t !== "scope") parallelText = niceName(raw);
      }
    }

    // If it says "patch" but not "relic", keep patch only (no forced relic)
    // If you want patch to count as relic for filtering, uncomment:
    // if (patch) relic = true;

    // Fallback player if empty
    if (!player) player = niceName(base);
  } else {
    // Fallback: old heuristic for older filenames
    const parts = base.split(/[-_]+/g).filter(Boolean);

    rc = /\brc\b|rookie/i.test(lower);
    auto = /\bauto\b|autograph|signature|\bsig\b/i.test(lower);
    patch = /\bpatch\b|relic|jersey/i.test(lower);
    relic = /\brelic\b/i.test(lower);

    const m1 = lower.match(/(\d+)\s*of\s*(\d+)/i);
    const m2 = lower.match(/(\d+)\s*\/\s*(\d+)/);
    if (m1) numbered = formatNumbered(m1[1], m1[2]);
    if (m2) numbered = formatNumbered(m2[1], m2[2]);

    parallel = /\bparallel\b|prizm|refractor|holo|foil|mosaic|scope|wave|tin-type|tintype/i.test(lower);
    if (/(tin-type|tintype)/i.test(lower)) parallelText = "Tin Type";

    // crude player inference
    const stopWords = new Set([
      "rc","rookie","auto","autograph","sig","signature","patch","relic","jersey",
      "numbered","parallel","prizm","refractor","holo","foil","mosaic","scope","wave","tin","type","tintype",
    ]);

    const isYear = (t: string) => /^\d{4}$/.test(t);
    const nameParts: string[] = [];

    for (const t of parts) {
      const tl = t.toLowerCase();
      if (isYear(tl)) break;
      if (stopWords.has(tl)) break;
      if (/^\d+of\d+$/i.test(t) || /^\d+\/\d+$/.test(t)) break;
      nameParts.push(t);
    }

    player = nameParts.length > 0 ? niceName(nameParts.join(" ")) : niceName(base);
    team = "";
  }

  return { player, team, rc, auto, patch, relic, numbered, parallel, parallelText };
}

export async function getStaticPaths() {
  const baseDir = path.join(process.cwd(), "public", "cards");
  const sports = ["baseball", "basketball", "football"];
  const paths: { params: { sport: string; set: string } }[] = [];

  // Case-safe sport folder detection (Linux-friendly on Cloudflare)
  const baseEntries = await fs.readdir(baseDir, { withFileTypes: true }).catch(() => []);
  const sportFolder = (sport: string) =>
    baseEntries.find((e) => e.isDirectory() && e.name.toLowerCase() === sport)?.name ?? sport;

  for (const sport of sports) {
    const folder = sportFolder(sport);
    const sportDir = path.join(baseDir, folder);
    const entries = await fs.readdir(sportDir, { withFileTypes: true }).catch(() => []);
    const sets = entries.filter((e) => e.isDirectory()).map((e) => e.name);
    for (const set of sets) paths.push({ params: { sport, set } });
  }

  return paths;
}

const sport = (Astro.params.sport ?? "").toString();
const set = (Astro.params.set ?? "").toString();

// Case-safe folder for runtime render
const baseDir = path.join(process.cwd(), "public", "cards");
const baseEntries = await fs.readdir(baseDir, { withFileTypes: true }).catch(() => []);
const folder =
  baseEntries.find((e) => e.isDirectory() && e.name.toLowerCase() === sport)?.name ?? sport;

const setDir = path.join(baseDir, folder, set);

// Prefer these subfolders if present
const frontWebpDir = path.join(setDir, "front-webp");
const backWebpDir = path.join(setDir, "back-webp");
const thumbsDir = path.join(setDir, "thumbs");

const hasFrontWebp = await dirExists(frontWebpDir);
const hasBackWebp = await dirExists(backWebpDir);
const hasThumbs = await dirExists(thumbsDir);

// Full-size source directory (lightbox) — fronts
const fullDir = hasFrontWebp ? frontWebpDir : setDir;
const fullSub = hasFrontWebp ? "front-webp" : null;

// Thumb source directory (grid)
const thumbDir = hasThumbs ? thumbsDir : fullDir;
const thumbSub = hasThumbs ? "thumbs" : fullSub;

// Read fronts
const frontFiles = (await fs.readdir(fullDir).catch(() => [])).filter(isImageFile);
frontFiles.sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" }));

// Read thumbs
const thumbFiles = (await fs.readdir(thumbDir).catch(() => [])).filter(isImageFile);
thumbFiles.sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" }));

// Map thumbs by normalized key (handles __front mismatch, etc.)
const thumbByKey = new Map<string, string>();
for (const f of thumbFiles) thumbByKey.set(cardKey(f), f);

// Read backs (optional)
const backFiles = hasBackWebp
  ? (await fs.readdir(backWebpDir).catch(() => [])).filter(isImageFile)
  : [];
backFiles.sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" }));

// Map backs by normalized key
const backByKey = new Map<string, string>();
for (const f of backFiles) backByKey.set(cardKey(f), f);

// optional meta.json at set root
let meta: MetaMap = {};
try {
  const metaPath = path.join(setDir, "meta.json");
  const raw = await fs.readFile(metaPath, "utf8");
  meta = JSON.parse(raw);
} catch {
  // no meta.json, that's fine
}

// Build cards list based on fronts
const cards = frontFiles.map((frontImg) => {
  const inferred = inferFromFilename(frontImg);
  const m = meta[frontImg] ?? {};

  const player = (m.player ?? inferred.player).toString();
  const team = (m.team ?? inferred.team ?? "").toString();

  const rc = Boolean(m.rc ?? inferred.rc);
  const auto = Boolean(m.auto ?? inferred.auto);
  const patch = Boolean(m.patch ?? inferred.patch);
  const relic = Boolean(m.relic ?? inferred.relic);
  const numbered = (m.numbered ?? inferred.numbered ?? "").toString();

  // parallel label priority: meta > inferred parallelText > inferred parallel boolean
  const parallelText = (m.parallel ?? inferred.parallelText ?? "").toString();
  const parallel = Boolean(parallelText) || Boolean(inferred.parallel);

  const tags = [
    rc ? "rc" : "",
    auto ? "auto" : "",
    patch ? "patch" : "",
    relic ? "relic" : "",
    numbered ? "numbered" : "",
    parallel ? "parallel" : "",
  ].filter(Boolean);

  const key = cardKey(frontImg);
  const thumbName = thumbByKey.get(key) ?? frontImg;

  const backImg = hasBackWebp ? (backByKey.get(key) ?? null) : null;

  return {
    img: frontImg,
    urlFront: toUrl(folder, set, fullSub, frontImg),
    urlThumb: toUrl(folder, set, thumbSub, thumbName),
    urlBack: backImg ? toUrl(folder, set, "back-webp", backImg) : null,
    hasBack: Boolean(backImg),

    player,
    team,
    rc,
    auto,
    patch,
    relic,
    numbered,
    parallel,
    parallelText,
    tags,
  };
});

const title = `${niceName(sport)} • ${niceName(set)}`;
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>{title}</title>
  </head>

  <body class="min-h-screen bg-zinc-950 text-zinc-100">
    <main class="mx-auto max-w-6xl px-4 py-10">
      <!-- Header -->
      <div class="flex items-center justify-between gap-4">
        <a href={`/${sport}/`} class="text-sm text-zinc-400 hover:text-zinc-200">
          ← Back to {niceName(sport)} sets
        </a>

        <div class="flex items-center gap-3">
          <img
            src="/brand/bradyrip.png"
            alt="BradyRip"
            class="h-8 w-8 rounded-full ring-1 ring-zinc-800 bg-zinc-900/40 object-contain"
            loading="lazy"
            onerror="this.style.display='none';"
          />
          <a href="/" class="text-sm text-zinc-400 hover:text-zinc-200">Home</a>
        </div>
      </div>

      <!-- Title -->
      <div class="mt-6">
        <h1 class="text-3xl font-semibold tracking-tight">{niceName(set)}</h1>
        <p class="mt-2 text-zinc-300">
          {niceName(sport)} • {cards.length} card{cards.length === 1 ? "" : "s"}
        </p>

        <p class="mt-2 text-xs text-zinc-500">
          Grid: <code class="rounded bg-zinc-900 px-1.5 py-0.5 ring-1 ring-zinc-800">{thumbSub ?? "(set root)"}</code>
          &nbsp;•&nbsp; Lightbox: <code class="rounded bg-zinc-900 px-1.5 py-0.5 ring-1 ring-zinc-800">{fullSub ?? "(set root)"}</code>
          {hasBackWebp ? (
            <>
              &nbsp;•&nbsp; Back: <code class="rounded bg-zinc-900 px-1.5 py-0.5 ring-1 ring-zinc-800">back-webp</code>
            </>
          ) : null}
        </p>
      </div>

      <!-- Search + quick filters -->
      <div class="mt-5 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
        <div class="flex-1">
          <input
            id="q"
            type="search"
            placeholder="Search player / team / filename…"
            class="w-full rounded-xl bg-zinc-950 ring-1 ring-zinc-800 px-4 py-2.5 text-sm text-zinc-100 placeholder:text-zinc-500 focus:outline-none focus:ring-2 focus:ring-zinc-600"
          />
        </div>

        <div class="flex flex-wrap gap-2">
          <button class="chip is-active" type="button" data-filter="all">All</button>
          <button class="chip" type="button" data-filter="rc">RC</button>
          <button class="chip" type="button" data-filter="auto">Auto</button>
          <button class="chip" type="button" data-filter="patch">Patch</button>
          <button class="chip" type="button" data-filter="relic">Relic</button>
          <button class="chip" type="button" data-filter="numbered">#’d</button>
          <button class="chip" type="button" data-filter="parallel">Parallel</button>
        </div>
      </div>

      {cards.length === 0 ? (
        <div class="mt-6 rounded-2xl ring-1 ring-zinc-800 p-6 text-zinc-300">
          No images found. Put card images in:
          <div class="mt-2 text-sm text-zinc-400">
            <code class="rounded bg-zinc-900 px-2 py-1 ring-1 ring-zinc-800">
              public/cards/{folder}/{set}/front-webp/
            </code>
            {" "}and thumbs in{" "}
            <code class="rounded bg-zinc-900 px-2 py-1 ring-1 ring-zinc-800">
              public/cards/{folder}/{set}/thumbs/
            </code>
            {hasBackWebp ? (
              <>
                {" "}and backs in{" "}
                <code class="rounded bg-zinc-900 px-2 py-1 ring-1 ring-zinc-800">
                  public/cards/{folder}/{set}/back-webp/
                </code>
              </>
            ) : null}
          </div>
        </div>
      ) : (
        <>
          {/* THUMB GRID */}
          <section class="mt-6 flex flex-wrap gap-3" id="grid">
            {cards.map((c, i) => (
              <button
                type="button"
                class="tile group w-[120px] sm:w-[135px] md:w-[150px] rounded-xl ring-1 ring-zinc-800 bg-zinc-950 overflow-hidden hover:ring-zinc-600 transition"
                data-open={i}
                data-q={`${c.player} ${c.team} ${c.img}`.toLowerCase()}
                data-tags={c.tags.join(",")}
                aria-label={`Open ${c.img}`}
                title={c.img}
              >
                <div class="aspect-[3/4] bg-zinc-900/25">
                  <img
                    src={c.urlThumb}
                    alt={c.img}
                    loading="lazy"
                    class="h-full w-full object-contain p-1.5 group-hover:scale-[1.02] transition"
                  />
                </div>

                <div class="px-2 py-2">
                  <div class="text-xs font-medium text-zinc-200 truncate">{c.player}</div>
                  {c.team ? <div class="mt-0.5 text-[10px] text-zinc-400 truncate">{c.team}</div> : null}

                  <div class="mt-1 flex flex-wrap gap-1">
                    {c.rc && <span class="pill">RC</span>}
                    {c.auto && <span class="pill">AUTO</span>}
                    {c.patch && <span class="pill">PATCH</span>}
                    {!c.patch && c.relic && <span class="pill">RELIC</span>}
                    {c.numbered && <span class="pill">#{c.numbered}</span>}
                    {c.parallel && <span class="pill">{c.parallelText ? c.parallelText : "PAR"}</span>}
                    {c.hasBack && <span class="pill">2-SIDED</span>}
                  </div>
                </div>
              </button>
            ))}
          </section>

          {/* LIGHTBOX */}
          <div
            id="lightbox"
            class="fixed inset-0 z-50 hidden items-center justify-center bg-black/80 p-4"
            aria-hidden="true"
          >
            <div class="absolute inset-0" data-close></div>

            <div class="relative w-full max-w-4xl">
              <div class="rounded-2xl bg-zinc-950 ring-1 ring-zinc-800 overflow-hidden">
                <div class="flex items-center justify-between px-4 py-3 border-b border-zinc-800">
                  <div class="text-sm text-zinc-300 truncate" id="lb-label"></div>
                  <button
                    type="button"
                    class="text-sm text-zinc-300 hover:text-white rounded-lg px-3 py-1.5 ring-1 ring-zinc-700/70 hover:ring-zinc-500"
                    data-close
                  >
                    Close
                  </button>
                </div>

                <div class="bg-black/30">
                  <img id="lb-img" src="" alt="" class="w-full max-h-[80vh] object-contain" />
                </div>

                <div class="flex items-center justify-between px-4 py-3 border-t border-zinc-800 gap-2">
                  <button
                    type="button"
                    class="text-sm text-zinc-300 hover:text-white rounded-lg px-3 py-1.5 ring-1 ring-zinc-700/70 hover:ring-zinc-500"
                    id="lb-prev"
                  >
                    ← Prev
                  </button>

                  <div class="flex items-center gap-2">
                    <button
                      type="button"
                      class="text-sm text-zinc-300 hover:text-white rounded-lg px-3 py-1.5 ring-1 ring-zinc-700/70 hover:ring-zinc-500 disabled:opacity-40 disabled:cursor-not-allowed"
                      id="lb-flip"
                    >
                      View Back
                    </button>
                    <div class="text-xs text-zinc-400" id="lb-count"></div>
                  </div>

                  <button
                    type="button"
                    class="text-sm text-zinc-300 hover:text-white rounded-lg px-3 py-1.5 ring-1 ring-zinc-700/70 hover:ring-zinc-500"
                    id="lb-next"
                  >
                    Next →
                  </button>
                </div>
              </div>
            </div>
          </div>

          <style>
            .chip{
              border-radius:999px;
              padding:8px 10px;
              font-size:12px;
              line-height:1;
              background:rgba(9,9,11,1);
              border:1px solid rgba(39,39,42,1);
              color:rgba(212,212,216,1);
              transition:.15s ease;
              white-space:nowrap;
            }
            .chip:hover{border-color:rgba(82,82,91,1)}
            .chip.is-active{
              background:rgba(24,24,27,.85);
              border-color:rgba(82,82,91,1);
              color:#fff;
            }
            .pill{
              font-size:10px;
              padding:2px 6px;
              border-radius:999px;
              border:1px solid rgba(39,39,42,1);
              background:rgba(24,24,27,.6);
              color:rgba(212,212,216,1);
            }
          </style>

          {/* Inline script (search/filter + lightbox + flip) */}
          <script define:vars={{ cards }}>
            const lb = document.getElementById("lightbox");
            const lbImg = document.getElementById("lb-img");
            const lbLabel = document.getElementById("lb-label");
            const lbCount = document.getElementById("lb-count");
            const prevBtn = document.getElementById("lb-prev");
            const nextBtn = document.getElementById("lb-next");
            const flipBtn = document.getElementById("lb-flip");

            const q = document.getElementById("q");
            const grid = document.getElementById("grid");
            const chips = Array.from(document.querySelectorAll(".chip"));

            let idx = 0;
            let active = "all";
            let side = "front"; // "front" | "back"

            function setLightboxText() {
              const c = cards[idx];
              const sideLabel = (side === "back") ? "Back" : "Front";
              const team = c.team ? ` • ${c.team}` : "";
              lbLabel.textContent = `${c.player}${team} • ${sideLabel}`;
              lbCount.textContent = `${idx + 1} / ${cards.length}`;
            }

            function render() {
              const c = cards[idx];
              const hasBack = Boolean(c.urlBack);
              const url = (side === "back" && hasBack) ? c.urlBack : c.urlFront;

              lbImg.src = url;
              lbImg.alt = c.img;

              if (flipBtn) {
                flipBtn.disabled = !hasBack;
                flipBtn.textContent = !hasBack ? "No Back" : (side === "front" ? "View Back" : "View Front");
              }

              setLightboxText();
            }

            function show(i) {
              idx = (i + cards.length) % cards.length;
              side = "front";
              render();
              lb.classList.remove("hidden");
              lb.classList.add("flex");
              lb.setAttribute("aria-hidden", "false");
            }

            function close() {
              lb.classList.add("hidden");
              lb.classList.remove("flex");
              lb.setAttribute("aria-hidden", "true");
              lbImg.src = "";
              side = "front";
            }

            function applyFilter() {
              const term = (q?.value || "").toLowerCase().trim();
              const tiles = Array.from(grid?.querySelectorAll(".tile") || []);

              tiles.forEach((el) => {
                const hay = (el.getAttribute("data-q") || "");
                const tags = (el.getAttribute("data-tags") || "").split(",").filter(Boolean);

                const matchesText = !term || hay.includes(term);
                const matchesTag = active === "all" || tags.includes(active);

                el.style.display = (matchesText && matchesTag) ? "" : "none";
              });
            }

            document.querySelectorAll("[data-open]").forEach((btn) => {
              btn.addEventListener("click", () => show(parseInt(btn.dataset.open, 10)));
            });

            lb.querySelectorAll("[data-close]").forEach((el) => el.addEventListener("click", close));

            prevBtn.addEventListener("click", () => show(idx - 1));
            nextBtn.addEventListener("click", () => show(idx + 1));

            flipBtn?.addEventListener("click", () => {
              const c = cards[idx];
              if (!c.urlBack) return;
              side = (side === "front") ? "back" : "front";
              render();
            });

            q?.addEventListener("input", applyFilter);

            chips.forEach((btn) => {
              btn.addEventListener("click", () => {
                chips.forEach((b) => b.classList.remove("is-active"));
                btn.classList.add("is-active");
                active = btn.getAttribute("data-filter") || "all";
                applyFilter();
              });
            });

            window.addEventListener("keydown", (e) => {
              if (!lb || lb.classList.contains("hidden")) return;

              if (e.key === "Escape") close();
              if (e.key === "ArrowLeft") show(idx - 1);
              if (e.key === "ArrowRight") show(idx + 1);

              // Flip hotkey: "b"
              if (e.key.toLowerCase() === "b") {
                const c = cards[idx];
                if (!c.urlBack) return;
                side = (side === "front") ? "back" : "front";
                render();
              }
            });
          </script>
        </>
      )}
    </main>
  </body>
</html>
