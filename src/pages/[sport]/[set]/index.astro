---
import "../../../styles/global.css";
import fs from "node:fs/promises";
import path from "node:path";

function niceName(slug: string) {
  return slug
    .replace(/[-_]+/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .replace(/\b\w/g, (c) => c.toUpperCase());
}

type MetaEntry = {
  player?: string;
  team?: string;
  rc?: boolean;
  parallel?: string | null;
  numbered?: string | null; // ex: "12/25"
};

type MetaMap = Record<string, MetaEntry>;

type Card = {
  file: string;
  url: string;
  player: string;
  team: string;
  parallel: string | null;
  numbered: string | null;
  rc: boolean;
};

function stripExt(file: string) {
  return file.replace(/\.[^.]+$/, "");
}

export async function getStaticPaths() {
  const baseDir = path.join(process.cwd(), "public", "cards");
  const sports = ["baseball", "basketball", "football"];
  const paths: { params: { sport: string; set: string } }[] = [];

  // Case-safe sport folder detection (Linux-friendly on Cloudflare)
  const baseEntries = await fs.readdir(baseDir, { withFileTypes: true }).catch(() => []);
  const sportFolder = (sport: string) =>
    baseEntries.find((e) => e.isDirectory() && e.name.toLowerCase() === sport)?.name ?? sport;

  for (const sport of sports) {
    const folder = sportFolder(sport);
    const sportDir = path.join(baseDir, folder);
    const entries = await fs.readdir(sportDir, { withFileTypes: true }).catch(() => []);
    const sets = entries.filter((e) => e.isDirectory()).map((e) => e.name);

    for (const set of sets) paths.push({ params: { sport, set } });
  }

  return paths;
}

const sport = (Astro.params.sport ?? "").toString();
const set = (Astro.params.set ?? "").toString();

// Case-safe folder for runtime render
const baseDir = path.join(process.cwd(), "public", "cards");
const baseEntries = await fs.readdir(baseDir, { withFileTypes: true }).catch(() => []);
const folder =
  baseEntries.find((e) => e.isDirectory() && e.name.toLowerCase() === sport)?.name ?? sport;

const setDir = path.join(baseDir, folder, set);

// Read images
const files = await fs.readdir(setDir).catch(() => []);
const images = files
  .filter((f) => /\.(webp|png|jpe?g|gif)$/i.test(f))
  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" }));

// Read metadata
let meta: MetaMap = {};
let metaError: string | null = null;

try {
  const raw = await fs.readFile(path.join(setDir, "cards.meta.json"), "utf8");
  meta = JSON.parse(raw);
} catch (e: any) {
  // If the file doesn't exist, that's fine. If it exists but is invalid, show a warning.
  // We only store the error message; page still works.
  meta = {};
  // Try to detect if file exists to avoid warning on "no file"
  try {
    await fs.access(path.join(setDir, "cards.meta.json"));
    metaError = e?.message ?? "Invalid cards.meta.json";
  } catch {
    metaError = null;
  }
}

// Build a case-insensitive lookup map for meta keys
const metaLower = new Map<string, MetaEntry>();
for (const [k, v] of Object.entries(meta)) {
  metaLower.set(k.toLowerCase(), v);
}

function getMetaForImage(img: string): MetaEntry {
  // exact key
  if (meta[img]) return meta[img];

  // case-insensitive exact filename
  const lowerHit = metaLower.get(img.toLowerCase());
  if (lowerHit) return lowerHit;

  // try without extension
  const base = stripExt(img);
  if (meta[base]) return meta[base];
  const baseLowerHit = metaLower.get(base.toLowerCase());
  if (baseLowerHit) return baseLowerHit;

  return {};
}

const cards: Card[] = images.map((img) => {
  const m = getMetaForImage(img);

  return {
    file: img,
    url: `/cards/${folder}/${set}/${img}`,
    player: (m.player ?? "").trim() || niceName(stripExt(img)),
    team: (m.team ?? "").trim() || "",
    parallel: m.parallel ?? null,
    numbered: m.numbered ?? null,
    rc: Boolean(m.rc),
  };
});

const title = `${niceName(sport)} • ${niceName(set)}`;

// For the lightbox script
const cardData = cards.map((c) => ({
  url: c.url,
  file: c.file,
  player: c.player,
  team: c.team,
  parallel: c.parallel,
  numbered: c.numbered,
  rc: c.rc,
}));
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>{title}</title>
  </head>

  <body class="min-h-screen bg-zinc-950 text-zinc-100">
    <main class="mx-auto max-w-6xl px-4 py-10">
      <div class="flex items-center justify-between gap-4">
        <a href={`/${sport}/`} class="text-sm text-zinc-400 hover:text-zinc-200">
          ← Back to {niceName(sport)} sets
        </a>

        <a href="/" class="text-sm text-zinc-400 hover:text-zinc-200">Home</a>
      </div>

      <div class="mt-6">
        <h1 class="text-3xl font-semibold tracking-tight">{niceName(set)}</h1>
        <p class="mt-2 text-zinc-300">
          {niceName(sport)} • {cards.length} card{cards.length === 1 ? "" : "s"}
        </p>
      </div>

      {metaError && (
        <div class="mt-4 rounded-xl ring-1 ring-red-900/50 bg-red-950/20 p-4 text-sm text-red-200">
          <div class="font-semibold">cards.meta.json problem</div>
          <div class="mt-1 text-red-200/90">
            {metaError}
          </div>
          <div class="mt-2 text-red-200/80">
            Fix it so it is ONE valid JSON object, and keys match the exact filename (including .webp).
          </div>
        </div>
      )}

      {cards.length === 0 ? (
        <div class="mt-6 rounded-2xl ring-1 ring-zinc-800 p-6 text-zinc-300">
          No images found in{" "}
          <code class="rounded bg-zinc-900 px-2 py-1 ring-1 ring-zinc-800">
            public/cards/{folder}/{set}/
          </code>
        </div>
      ) : (
        <>
          {/* THUMB GRID (small + info) */}
          <section class="mt-6 flex flex-wrap gap-2">
            {cards.ma
